/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
define(["exports","./Box3","./Vector3"],(function(t,e,i){"use strict";var r=new e.Box3,n=new i.Vector3,s=new i.Vector3,a=new i.Vector3,c=function(){function t(t,e){void 0===t&&(t=new i.Vector3),void 0===e&&(e=-1),this.center=t,this.radius=e}var e=t.prototype;return e.set=function(t,e){return this.center.copy(t),this.radius=e,this},e.setFromPoints=function(t,e){var i=this.center;void 0!==e?i.copy(e):r.setFromPoints(t).getCenter(i);for(var n=0,s=0,a=t.length;s<a;s++)n=Math.max(n,i.distanceToSquared(t[s]));return this.radius=Math.sqrt(n),this},e.copy=function(t){return this.center.copy(t.center),this.radius=t.radius,this},e.isEmpty=function(){return this.radius<0},e.makeEmpty=function(){return this.center.set(0,0,0),this.radius=-1,this},e.containsPoint=function(t){return t.distanceToSquared(this.center)<=this.radius*this.radius},e.distanceToPoint=function(t){return t.distanceTo(this.center)-this.radius},e.intersectsSphere=function(t){var e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e},e.intersectsBox=function(t){return t.intersectsSphere(this)},e.intersectsPlane=function(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius},e.clampPoint=function(t,e){var i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e},e.getBoundingBox=function(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)},e.applyMatrix4=function(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this},e.translate=function(t){return this.center.add(t),this},e.expandByPoint=function(t){a.subVectors(t,this.center);var e=a.lengthSq();if(e>this.radius*this.radius){var i=Math.sqrt(e),r=.5*(i-this.radius);this.center.add(a.multiplyScalar(r/i)),this.radius+=r}return this},e.union=function(t){return!0===this.center.equals(t.center)?s.set(0,0,1).multiplyScalar(t.radius):s.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(n.copy(t.center).add(s)),this.expandByPoint(n.copy(t.center).sub(s)),this},e.equals=function(t){return t.center.equals(this.center)&&t.radius===this.radius},e.clone=function(){return(new this.constructor).copy(this)},t}();t.Sphere=c,Object.defineProperty(t,"__esModule",{value:!0})}));
