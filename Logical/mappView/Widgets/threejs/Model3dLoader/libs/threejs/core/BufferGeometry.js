/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
define(["exports","../_virtual/_rollupPluginBabelHelpers","../math/Vector3","../math/Vector2","../math/Box3","./EventDispatcher","./BufferAttribute","../math/Sphere","./Object3D","../math/Matrix4","../math/Matrix3","../math/MathUtils","../utils"],(function(t,e,r,i,n,o,a,s,u,h,f,d,l){"use strict";var m=0,c=new h.Matrix4,p=new u.Object3D,b=new r.Vector3,g=new n.Box3,v=new n.Box3,y=new r.Vector3,x=function(t){function o(){var r;return(r=t.call(this)||this).isBufferGeometry=!0,Object.defineProperty(e.assertThisInitialized(r),"id",{value:m++}),r.uuid=d.generateUUID(),r.name="",r.type="BufferGeometry",r.index=null,r.attributes={},r.morphAttributes={},r.morphTargetsRelative=!1,r.groups=[],r.boundingBox=null,r.boundingSphere=null,r.drawRange={start:0,count:1/0},r.userData={},r}e.inheritsLoose(o,t);var u=o.prototype;return u.getIndex=function(){return this.index},u.setIndex=function(t){return Array.isArray(t)?this.index=new(l.arrayNeedsUint32(t)?a.Uint32BufferAttribute:a.Uint16BufferAttribute)(t,1):this.index=t,this},u.getAttribute=function(t){return this.attributes[t]},u.setAttribute=function(t,e){return this.attributes[t]=e,this},u.deleteAttribute=function(t){return delete this.attributes[t],this},u.hasAttribute=function(t){return void 0!==this.attributes[t]},u.addGroup=function(t,e,r){void 0===r&&(r=0),this.groups.push({start:t,count:e,materialIndex:r})},u.clearGroups=function(){this.groups=[]},u.setDrawRange=function(t,e){this.drawRange.start=t,this.drawRange.count=e},u.applyMatrix4=function(t){var e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);var r=this.attributes.normal;if(void 0!==r){var i=(new f.Matrix3).getNormalMatrix(t);r.applyNormalMatrix(i),r.needsUpdate=!0}var n=this.attributes.tangent;return void 0!==n&&(n.transformDirection(t),n.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},u.applyQuaternion=function(t){return c.makeRotationFromQuaternion(t),this.applyMatrix4(c),this},u.rotateX=function(t){return c.makeRotationX(t),this.applyMatrix4(c),this},u.rotateY=function(t){return c.makeRotationY(t),this.applyMatrix4(c),this},u.rotateZ=function(t){return c.makeRotationZ(t),this.applyMatrix4(c),this},u.translate=function(t,e,r){return c.makeTranslation(t,e,r),this.applyMatrix4(c),this},u.scale=function(t,e,r){return c.makeScale(t,e,r),this.applyMatrix4(c),this},u.lookAt=function(t){return p.lookAt(t),p.updateMatrix(),this.applyMatrix4(p.matrix),this},u.center=function(){return this.computeBoundingBox(),this.boundingBox.getCenter(b).negate(),this.translate(b.x,b.y,b.z),this},u.setFromPoints=function(t){for(var e=[],r=0,i=t.length;r<i;r++){var n=t[r];e.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new a.Float32BufferAttribute(e,3)),this},u.computeBoundingBox=function(){null===this.boundingBox&&(this.boundingBox=new n.Box3);var t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new r.Vector3(-1/0,-1/0,-1/0),new r.Vector3(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(var i=0,o=e.length;i<o;i++){var a=e[i];g.setFromBufferAttribute(a),this.morphTargetsRelative?(y.addVectors(this.boundingBox.min,g.min),this.boundingBox.expandByPoint(y),y.addVectors(this.boundingBox.max,g.max),this.boundingBox.expandByPoint(y)):(this.boundingBox.expandByPoint(g.min),this.boundingBox.expandByPoint(g.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},u.computeBoundingSphere=function(){null===this.boundingSphere&&(this.boundingSphere=new s.Sphere);var t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new r.Vector3,1/0);if(t){var i=this.boundingSphere.center;if(g.setFromBufferAttribute(t),e)for(var n=0,o=e.length;n<o;n++){var a=e[n];v.setFromBufferAttribute(a),this.morphTargetsRelative?(y.addVectors(g.min,v.min),g.expandByPoint(y),y.addVectors(g.max,v.max),g.expandByPoint(y)):(g.expandByPoint(v.min),g.expandByPoint(v.max))}g.getCenter(i);for(var u=0,h=0,f=t.count;h<f;h++)y.fromBufferAttribute(t,h),u=Math.max(u,i.distanceToSquared(y));if(e)for(var d=0,l=e.length;d<l;d++)for(var m=e[d],c=this.morphTargetsRelative,p=0,x=m.count;p<x;p++)y.fromBufferAttribute(m,p),c&&(b.fromBufferAttribute(t,p),y.add(b)),u=Math.max(u,i.distanceToSquared(y));this.boundingSphere.radius=Math.sqrt(u),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},u.computeTangents=function(){var t=this.index,e=this.attributes;if(null!==t&&void 0!==e.position&&void 0!==e.normal&&void 0!==e.uv){var n=t.array,o=e.position.array,s=e.normal.array,u=e.uv.array,h=o.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new a.BufferAttribute(new Float32Array(4*h),4));for(var f=this.getAttribute("tangent").array,d=[],l=[],m=0;m<h;m++)d[m]=new r.Vector3,l[m]=new r.Vector3;var c=new r.Vector3,p=new r.Vector3,b=new r.Vector3,g=new i.Vector2,v=new i.Vector2,y=new i.Vector2,x=new r.Vector3,B=new r.Vector3,A=this.groups;0===A.length&&(A=[{start:0,count:n.length}]);for(var w=0,V=A.length;w<V;++w)for(var S=A[w],R=S.start,N=R,T=R+S.count;N<T;N+=3)I(n[N+0],n[N+1],n[N+2]);for(var G=new r.Vector3,M=new r.Vector3,E=new r.Vector3,z=new r.Vector3,D=0,O=A.length;D<O;++D)for(var X=A[D],k=X.start,P=k,U=k+X.count;P<U;P+=3)F(n[P+0]),F(n[P+1]),F(n[P+2])}else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function I(t,e,r){c.fromArray(o,3*t),p.fromArray(o,3*e),b.fromArray(o,3*r),g.fromArray(u,2*t),v.fromArray(u,2*e),y.fromArray(u,2*r),p.sub(c),b.sub(c),v.sub(g),y.sub(g);var i=1/(v.x*y.y-y.x*v.y);isFinite(i)&&(x.copy(p).multiplyScalar(y.y).addScaledVector(b,-v.y).multiplyScalar(i),B.copy(b).multiplyScalar(v.x).addScaledVector(p,-y.x).multiplyScalar(i),d[t].add(x),d[e].add(x),d[r].add(x),l[t].add(B),l[e].add(B),l[r].add(B))}function F(t){E.fromArray(s,3*t),z.copy(E);var e=d[t];G.copy(e),G.sub(E.multiplyScalar(E.dot(e))).normalize(),M.crossVectors(z,e);var r=M.dot(l[t])<0?-1:1;f[4*t]=G.x,f[4*t+1]=G.y,f[4*t+2]=G.z,f[4*t+3]=r}},u.computeVertexNormals=function(){var t=this.index,e=this.getAttribute("position");if(void 0!==e){var i=this.getAttribute("normal");if(void 0===i)i=new a.BufferAttribute(new Float32Array(3*e.count),3),this.setAttribute("normal",i);else for(var n=0,o=i.count;n<o;n++)i.setXYZ(n,0,0,0);var s=new r.Vector3,u=new r.Vector3,h=new r.Vector3,f=new r.Vector3,d=new r.Vector3,l=new r.Vector3,m=new r.Vector3,c=new r.Vector3;if(t)for(var p=0,b=t.count;p<b;p+=3){var g=t.getX(p+0),v=t.getX(p+1),y=t.getX(p+2);s.fromBufferAttribute(e,g),u.fromBufferAttribute(e,v),h.fromBufferAttribute(e,y),m.subVectors(h,u),c.subVectors(s,u),m.cross(c),f.fromBufferAttribute(i,g),d.fromBufferAttribute(i,v),l.fromBufferAttribute(i,y),f.add(m),d.add(m),l.add(m),i.setXYZ(g,f.x,f.y,f.z),i.setXYZ(v,d.x,d.y,d.z),i.setXYZ(y,l.x,l.y,l.z)}else for(var x=0,B=e.count;x<B;x+=3)s.fromBufferAttribute(e,x+0),u.fromBufferAttribute(e,x+1),h.fromBufferAttribute(e,x+2),m.subVectors(h,u),c.subVectors(s,u),m.cross(c),i.setXYZ(x+0,m.x,m.y,m.z),i.setXYZ(x+1,m.x,m.y,m.z),i.setXYZ(x+2,m.x,m.y,m.z);this.normalizeNormals(),i.needsUpdate=!0}},u.merge=function(t,e){if(t&&t.isBufferGeometry){void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var r=this.attributes;for(var i in r)if(void 0!==t.attributes[i])for(var n=r[i].array,o=t.attributes[i],a=o.array,s=o.itemSize*e,u=Math.min(a.length,n.length-s),h=0,f=s;h<u;h++,f++)n[f]=a[h];return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t)},u.normalizeNormals=function(){for(var t=this.attributes.normal,e=0,r=t.count;e<r;e++)y.fromBufferAttribute(t,e),y.normalize(),t.setXYZ(e,y.x,y.y,y.z)},u.toNonIndexed=function(){function t(t,e){for(var r=t.array,i=t.itemSize,n=t.normalized,o=new r.constructor(e.length*i),s=0,u=0,h=0,f=e.length;h<f;h++){s=t.isInterleavedBufferAttribute?e[h]*t.data.stride+t.offset:e[h]*i;for(var d=0;d<i;d++)o[u++]=r[s++]}return new a.BufferAttribute(o,i,n)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;var e=new o,r=this.index.array,i=this.attributes;for(var n in i){var s=t(i[n],r);e.setAttribute(n,s)}var u=this.morphAttributes;for(var h in u){for(var f=[],d=u[h],l=0,m=d.length;l<m;l++){var c=t(d[l],r);f.push(c)}e.morphAttributes[h]=f}e.morphTargetsRelative=this.morphTargetsRelative;for(var p=this.groups,b=0,g=p.length;b<g;b++){var v=p[b];e.addGroup(v.start,v.count,v.materialIndex)}return e},u.toJSON=function(){var t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){var e=this.parameters;for(var r in e)void 0!==e[r]&&(t[r]=e[r]);return t}t.data={attributes:{}};var i=this.index;null!==i&&(t.data.index={type:i.array.constructor.name,array:Array.prototype.slice.call(i.array)});var n=this.attributes;for(var o in n){var a=n[o];t.data.attributes[o]=a.toJSON(t.data)}var s={},u=!1;for(var h in this.morphAttributes){for(var f=this.morphAttributes[h],d=[],l=0,m=f.length;l<m;l++){var c=f[l];d.push(c.toJSON(t.data))}d.length>0&&(s[h]=d,u=!0)}u&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);var p=this.groups;p.length>0&&(t.data.groups=JSON.parse(JSON.stringify(p)));var b=this.boundingSphere;return null!==b&&(t.data.boundingSphere={center:b.center.toArray(),radius:b.radius}),t},u.clone=function(){return(new this.constructor).copy(this)},u.copy=function(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;var e={};this.name=t.name;var r=t.index;null!==r&&this.setIndex(r.clone(e));var i=t.attributes;for(var n in i){var o=i[n];this.setAttribute(n,o.clone(e))}var a=t.morphAttributes;for(var s in a){for(var u=[],h=a[s],f=0,d=h.length;f<d;f++)u.push(h[f].clone(e));this.morphAttributes[s]=u}this.morphTargetsRelative=t.morphTargetsRelative;for(var l=t.groups,m=0,c=l.length;m<c;m++){var p=l[m];this.addGroup(p.start,p.count,p.materialIndex)}var b=t.boundingBox;null!==b&&(this.boundingBox=b.clone());var g=t.boundingSphere;return null!==g&&(this.boundingSphere=g.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this},u.dispose=function(){this.dispatchEvent({type:"dispose"})},o}(o.EventDispatcher);t.BufferGeometry=x,Object.defineProperty(t,"__esModule",{value:!0})}));
