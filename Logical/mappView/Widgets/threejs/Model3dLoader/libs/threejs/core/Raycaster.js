/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
define(["exports","../math/Ray","./Layers"],(function(r,t,e){"use strict";var i=function(){function r(r,i,a,s){void 0===a&&(a=0),void 0===s&&(s=1/0),this.ray=new t.Ray(r,i),this.near=a,this.far=s,this.camera=null,this.layers=new e.Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}var i=r.prototype;return i.set=function(r,t){this.ray.set(r,t)},i.setFromCamera=function(r,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(r.x,r.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(r.x,r.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},i.intersectObject=function(r,t,e){return void 0===t&&(t=!0),void 0===e&&(e=[]),s(r,this,e,t),e.sort(a),e},i.intersectObjects=function(r,t,e){void 0===t&&(t=!0),void 0===e&&(e=[]);for(var i=0,n=r.length;i<n;i++)s(r[i],this,e,t);return e.sort(a),e},r}();function a(r,t){return r.distance-t.distance}function s(r,t,e,i){if(r.layers.test(t.layers)&&r.raycast(t,e),!0===i)for(var a=r.children,n=0,o=a.length;n<o;n++)s(a[n],t,e,!0)}r.Raycaster=i,Object.defineProperty(r,"__esModule",{value:!0})}));
