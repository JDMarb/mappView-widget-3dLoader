/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
define(["exports","../constants","../core/BufferAttribute","../core/BufferGeometry","../objects/Mesh","../cameras/OrthographicCamera","../cameras/PerspectiveCamera","../materials/ShaderMaterial","../math/Vector3","../math/Color","../renderers/WebGLRenderTarget","../materials/MeshBasicMaterial","../geometries/BoxGeometry"],(function(t,e,n,i,r,a,o,s,u,l,c,d,p){"use strict";var v=[.125,.215,.35,.446,.526,.582],h=20,f=new a.OrthographicCamera,g=new l.Color,m=null,_=(1+Math.sqrt(5))/2,M=1/_,x=[new u.Vector3(1,1,1),new u.Vector3(-1,1,1),new u.Vector3(1,1,-1),new u.Vector3(-1,1,-1),new u.Vector3(0,_,M),new u.Vector3(0,_,-M),new u.Vector3(M,0,_),new u.Vector3(-M,0,_),new u.Vector3(_,M,0),new u.Vector3(-_,M,0)],b=function(){function t(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}var a=t.prototype;return a.fromScene=function(t,e,n,i){void 0===e&&(e=0),void 0===n&&(n=.1),void 0===i&&(i=100),m=this._renderer.getRenderTarget(),this._setSize(256);var r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r},a.fromEquirectangular=function(t,e){return void 0===e&&(e=null),this._fromTexture(t,e)},a.fromCubemap=function(t,e){return void 0===e&&(e=null),this._fromTexture(t,e)},a.compileCubemapShader=function(){null===this._cubemapMaterial&&(this._cubemapMaterial=z(),this._compileMaterial(this._cubemapMaterial))},a.compileEquirectangularShader=function(){null===this._equirectMaterial&&(this._equirectMaterial=y(),this._compileMaterial(this._equirectMaterial))},a.dispose=function(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()},a._setSize=function(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)},a._dispose=function(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(var t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()},a._cleanup=function(t){this._renderer.setRenderTarget(m),t.scissorTest=!1,w(t,0,0,t.width,t.height)},a._fromTexture=function(t,n){t.mapping===e.CubeReflectionMapping||t.mapping===e.CubeRefractionMapping?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),m=this._renderer.getRenderTarget();var i=n||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i},a._allocateTargets=function(){var t=3*Math.max(this._cubeSize,112),r=4*this._cubeSize,a={magFilter:e.LinearFilter,minFilter:e.LinearFilter,generateMipmaps:!1,type:e.HalfFloatType,format:e.RGBAFormat,encoding:e.LinearEncoding,depthBuffer:!1},o=T(t,r,a);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=T(t,r,a);var l=this._lodMax,c=function(t){for(var e=[],r=[],a=[],o=t,s=t-4+1+v.length,u=0;u<s;u++){var l=Math.pow(2,o);r.push(l);var c=1/l;u>t-4?c=v[u-t+4-1]:0===u&&(c=0),a.push(c);for(var d=1/(l-2),p=-d,h=1+d,f=[p,p,h,p,h,h,p,p,h,h,p,h],g=6,m=6,_=3,M=2,x=1,b=new Float32Array(_*m*g),T=new Float32Array(M*m*g),w=new Float32Array(x*m*g),y=0;y<g;y++){var z=y%3*2/3-1,C=y>2?0:-1,P=[z,C,0,z+2/3,C,0,z+2/3,C+1,0,z,C,0,z+2/3,C+1,0,z,C+1,0];b.set(P,_*m*y),T.set(f,M*m*y);var R=[y,y,y,y,y,y];w.set(R,x*m*y)}var D=new i.BufferGeometry;D.setAttribute("position",new n.BufferAttribute(b,_)),D.setAttribute("uv",new n.BufferAttribute(T,M)),D.setAttribute("faceIndex",new n.BufferAttribute(w,x)),e.push(D),o>4&&o--}return{lodPlanes:e,sizeLods:r,sigmas:a}}(l);this._sizeLods=c.sizeLods,this._lodPlanes=c.lodPlanes,this._sigmas=c.sigmas,this._blurMaterial=function(t,n,i){var r=new Float32Array(h),a=new u.Vector3(0,1,0);return new s.ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:h,CUBEUV_TEXEL_WIDTH:1/n,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:t+".0"},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:e.NoBlending,depthTest:!1,depthWrite:!1})}(l,t,r)}return o},a._compileMaterial=function(t){var e=new r.Mesh(this._lodPlanes[0],t);this._renderer.compile(e,f)},a._sceneToCubeUV=function(t,n,i,a){var s=new o.PerspectiveCamera(90,1,n,i),u=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],c=this._renderer,v=c.autoClear,h=c.toneMapping;c.getClearColor(g),c.toneMapping=e.NoToneMapping,c.autoClear=!1;var f=new d.MeshBasicMaterial({name:"PMREM.Background",side:e.BackSide,depthWrite:!1,depthTest:!1}),m=new r.Mesh(new p.BoxGeometry,f),_=!1,M=t.background;M?M.isColor&&(f.color.copy(M),t.background=null,_=!0):(f.color.copy(g),_=!0);for(var x=0;x<6;x++){var b=x%3;0===b?(s.up.set(0,u[x],0),s.lookAt(l[x],0,0)):1===b?(s.up.set(0,0,u[x]),s.lookAt(0,l[x],0)):(s.up.set(0,u[x],0),s.lookAt(0,0,l[x]));var T=this._cubeSize;w(a,b*T,x>2?T:0,T,T),c.setRenderTarget(a),_&&c.render(m,s),c.render(t,s)}m.geometry.dispose(),m.material.dispose(),c.toneMapping=h,c.autoClear=v,t.background=M},a._textureToCubeUV=function(t,n){var i=this._renderer,a=t.mapping===e.CubeReflectionMapping||t.mapping===e.CubeRefractionMapping;a?(null===this._cubemapMaterial&&(this._cubemapMaterial=z()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=y());var o=a?this._cubemapMaterial:this._equirectMaterial,s=new r.Mesh(this._lodPlanes[0],o);o.uniforms.envMap.value=t;var u=this._cubeSize;w(n,0,0,3*u,2*u),i.setRenderTarget(n),i.render(s,f)},a._applyPMREM=function(t){var e=this._renderer,n=e.autoClear;e.autoClear=!1;for(var i=1;i<this._lodPlanes.length;i++){var r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),a=x[(i-1)%x.length];this._blur(t,i-1,i,r,a)}e.autoClear=n},a._blur=function(t,e,n,i,r){var a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",r),this._halfBlur(a,t,n,n,i,"longitudinal",r)},a._halfBlur=function(t,e,n,i,a,o,s){var u=this._renderer,l=this._blurMaterial;"latitudinal"!==o&&"longitudinal"!==o&&console.error("blur direction must be either latitudinal or longitudinal!");var c=new r.Mesh(this._lodPlanes[i],l),d=l.uniforms,p=this._sizeLods[n]-1,v=isFinite(a)?Math.PI/(2*p):2*Math.PI/39,g=a/v,m=isFinite(a)?1+Math.floor(3*g):h;m>h&&console.warn("sigmaRadians, "+a+", is too large and will clip, as it requested "+m+" samples when the maximum is set to "+h);for(var _=[],M=0,x=0;x<h;++x){var b=x/g,T=Math.exp(-b*b/2);_.push(T),0===x?M+=T:x<m&&(M+=2*T)}for(var y=0;y<_.length;y++)_[y]=_[y]/M;d.envMap.value=t.texture,d.samples.value=m,d.weights.value=_,d.latitudinal.value="latitudinal"===o,s&&(d.poleAxis.value=s);var z=this._lodMax;d.dTheta.value=v,d.mipInt.value=z-n;var C=this._sizeLods[i];w(e,3*C*(i>z-4?i-z+4:0),4*(this._cubeSize-C),3*C,2*C),u.setRenderTarget(e),u.render(c,f)},t}();function T(t,n,i){var r=new c.WebGLRenderTarget(t,n,i);return r.texture.mapping=e.CubeUVReflectionMapping,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function w(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function y(){return new s.ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:e.NoBlending,depthTest:!1,depthWrite:!1})}function z(){return new s.ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:e.NoBlending,depthTest:!1,depthWrite:!1})}t.PMREMGenerator=b,Object.defineProperty(t,"__esModule",{value:!0})}));
